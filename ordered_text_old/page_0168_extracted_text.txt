--- PAGE 1 ---
Septembar 2024. Copyright 2018-2024 by Dragan Milićev
Prevođenje
❖ Međutim, osim toga, prevodilac u prevedenom fajlu ostavlja i informacije o 
svim imenima (simbolima) koji su deﬁnisani u datom fajlu, a mogu se 
koristiti u drugim fajlovima; ovakva imena nazivaju se imena sa spoljašnjim 
vezivanjem (external linking)
❖ U posebnom delu objektnog fajla, tipično u zaglavlju, prevodilac pravi 
tabelu takvih, izvezenih simbola, ostavljajući samo informaciju o:
• imenu (simbolu, prost niz znakova), bez ikakvih informacija o tome 
kakav je entitet predstavljalo to ime u programu (šta je, kog je tipa itd.)
• adresi, relativnoj u odnosu na početak binarnog prevoda (ili segmenta) 
u koji se to ime preslikava
❖ Na primer, po pravilima jezika C++, globalni objekat ili funkcija ima 
spoljašnje vezivanje, osim ako je eksplicitno deklarisana kao static (tada ima 
interno vezivanje)
❖ Imena koja imaju interno vezivanje (internal linking) ne mogu se koristiti u 
drugim fajlovima; prevodilac za ovakva imena ne ostavlja ovakve 
informacije u generisanoj tabeli simbola u objektnom fajlu
 168
int n = -16; 
void f () { 
  n++; 
}
A.cpp
symbols 
  ↑n: data:0 
  ↑f: code:0 
end symbols 
seg data 
n: ff ff ff f0 
end seg 
 
seg code 
f: ld r1,n 
   inc r1 
   st r1,n 
   ret 
end seg 
A.obj

--- PAGE 2 ---
Septembar 2024. Copyright 2018-2024 by Dragan Milićev
Prevođenje
❖ Sada deﬁnisane entitete želimo da koristimo u drugom fajlu B.cpp, ali tako da 
se odnose na entitete već deﬁnisane u A.cpp:
// B.cpp 
 
void g () { 
  n++; 
  f(); 
} 
❖ Ako se u ovom fajlu ne navede deklaracija objekta n i funkcije f, prevodilac će 
prijaviti grešku jer identiﬁkator nije deklarisan
❖ Ako se u B.cpp navede sledeća deklaracija:
int n; 
onda će prevodilac nju i dalje smatrati deﬁnicijom, i ponovo će alocirati prostor 
za taj objekat, iako nije inicijalizovan; osim toga, mogao bi da operacije sa n u 
potpunosti prevede, koristeći adresiranje lokacije tog alociranog prostora
❖ Ovo nije željeno ponašanje, već želimo da se ove operacije odnose na n i f 
deﬁnisane u drugom fajlu A.cpp, a ne da se deﬁnišu novi entiteti
 169
int n; 
void g () { 
  n++; 
  f(); 
}
B.cpp
symbols 
  ↑n: data:0 
  ↑g: code:0 
end symbols 
seg data 
n: 00 00 00 00 
end seg 
 
seg code 
g: ld r1,n 
   inc r1 
   st r1,n 
   call f 
   ret 
end seg 
B.obj
