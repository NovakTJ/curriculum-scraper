--- PAGE 1 ---
Septembar 2024. Copyright 2018-2024 by Dragan Milićev
Hijerarhijska dekompozicija
❖ Generalizacijom se uvode osnovne klase koje 
uopštavaju, apstrahuju, grupišu zajednička svojstva i 
ponašanje posebnih klasa
❖ Sama činjenica da neke klase imaju zajednička svojstva 
ili operacije može, ali ne mora biti dobar razlog za 
uvođenje njihove generalizacije
❖ Osnovni motiv za generalizaciju jeste to što neka 
druga apstrakcija ili drugi deo softvera (klijent) ima 
potrebu da instance datih različitih pojedinačnih klasa 
posmatra  i koristi na isti način, kroz isti uopšteni 
interfejs, ne praveći razliku između njih
❖ Na primer, u programu za crtanje dijagrama, na crtežu 
(Drawing) se nalaze ﬁgure različitih vrsta: 
pravougaonici (Rectangle), poligonalne linije (Polyline), 
krugovi (Circle) itd. Kako ih iscrtati?
class Rectangle { 
public: 
  void draw (Viewport*); 
  … 
}; 
class Polyline { 
public: 
  void draw (Viewport*); 
  … 
}; 
class Circle { 
public: 
  void draw (Viewport*); 
  … 
}; 
void Drawing::draw (Viewport* vp) 
{ 
  // How to draw figures 
  // of different kind?  
} 
…
 125

--- PAGE 2 ---
Septembar 2024. Copyright 2018-2024 by Dragan Milićev
Hijerarhijska dekompozicija
❖ U nekom proceduralnom jeziku bismo se oslonili na već pokazano, klasično rešenje:
switch (fig->kind) { 
  case rectangle: drawRectangle(fig,vp); 
  case polyline: drawPolyline(fig,vp); 
  case circle: drawCircle(fig,vp); 
  … 
} 
❖ Pošto je Crtež (Drawing) klijent koji različite ﬁgure posmatra na isti način, jer sve želi da ih nacrta (draw), 
potrebna nam je generalizacija različitih vrsta ﬁgura
❖ Ova generalizacija onda grupiše i zajedničke osobine i zajednički interfejs posebnih klasa:
• činjenicu da se mogu smeštati na crtež
• uslugu da se iscrtaju
 126
*
figures
draw()
Figure
Drawing
Rectangle Polyline Circle
